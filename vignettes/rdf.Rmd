---
title: "From R to RDF"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{From R to RDF}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setupvignette, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

if (!requireNamespace("rdflib", quietly = TRUE)) {
  stop("Please install 'rdflib' to run this vignette.")
}

if (!requireNamespace("jsonld", quietly = TRUE)) {
  stop("Please install 'jsonld' to run this vignette.")
}
```

```{css, echo = FALSE}
    .small .table{
      font-size: 10px;
    }
```

The `dataset` package supports the creation of semantically enriched datasets that align with the principles outlined in *design.Rmd*: preserving meaning across the data lifecycle, enabling interoperability, and ensuring compliance with modern metadata standards. A key part of these design principles is the ability to export data in machine-readable formats that integrate smoothly with the semantic web.

One such format is the Resource Description Framework (RDF), which expresses data as **subject–predicate–object** triples. By converting R data into RDF, we make each observation and its attributes explicitly defined and linkable to external vocabularies. This allows datasets to be easily merged, queried, and interpreted across systems.

## Purpose

The goal of this vignette is to show how a tidy R dataset can be transformed into RDF triples while retaining all semantic annotations added via the `dataset` package. RDF enables:

- **Interoperability** – linking data to controlled vocabularies and ontologies
- **Precision** – carrying explicit definitions for every variable and observation
- **Reusability** – producing outputs that are both human- and machine-readable

Exporting to RDF is a natural extension of the semantic early-binding approach described in *design.Rmd*, where metadata is embedded at the moment of dataset creation. This ensures that when data leaves R, it already contains everything needed for FAIR (Findable, Accessible, Interoperable, Reusable) compliance.

## From tidy data to RDF triples

A tidy dataset, where each variable is a column and each observation is a row, maps cleanly to RDF triples:

- The **subject** represents an observation or entity (e.g., “Observation #1” or a URI for a country)
- The **predicate** represents a variable or attribute (e.g., GDP value, reference year, measurement unit)
- The **object** represents the value, which can be a literal (number, string, date) or a URI pointing to a definition

By structuring data this way, every cell in the dataset becomes an elementary semantic statement that can be validated, linked, and queried via SPARQL.


```{r setup}
library(dataset)
library(rdflib)
data("gdp")
```

## Creating a minimal semantically defined dataset

To illustrate the conversion from tidy data to RDF triples, we start with a very small dataset that contains:

- A unique identifier (`rowid`) for each observation
- A country code (`geo`) linked to an authoritative vocabulary

By defining both variables with `defined()`, we make their meaning explicit and machine-readable from the outset.

```{r smallgeo}
small_geo <- dataset_df(
  rowid = defined(
    paste0("eg:", seq_along(gdp$geo[1:3])),
    namespace = "http://example.com/dataset#"
  ),
  geo = defined(
    gdp$geo[1:3],
    label = "Geopolitical entity",
    concept = "http://purl.org/linked-data/sdmx/2009/dimension#refArea",
    namespace = "https://dd.eionet.europa.eu/vocabulary/eurostat/geo/$1"
  )
)
```

Once the dataset is defined, we can convert it to RDF triples.

::: small
```{r triplesdf}
triples_df <- dataset_to_triples(small_geo)
knitr::kable(triples_df)
```
:::

This produces triples like:

::: small
```{r createntriples}
ntriples <- dataset_to_triples(small_geo, format = "nt")
cat(ntriples, sep = "\n")
```
:::

Each row of your dataset becomes a **subject**, each variable a **predicate**, and each value either a **URI** or a typed literal (like a date or number) — depending on how it's defined.

## RDF triples enable interoperability

The *Resource Description Framework* (RDF) represents data as a series of subject–predicate–object triples.  
In this representation:

- The **subject** is the entity or observation being described
- The **predicate** is the property or relationship
- The **object** is the value, which may be a literal (e.g., a string, number, or date) or another URI

With `dataset_df` and `defined` variables, each triple links directly to authoritative concept definitions and controlled vocabularies. This means that every cell in your dataset is expressed as a precise semantic statement, making it unambiguous, machine-readable, and easy to integrate into linked data systems.



```{r ntripleexample}
one_triple <- n_triple(
  s = "http://example.com/dataset#eg:1",
  p = "http://purl.org/dc/terms/title",
  o = "Small Country Dataset"
)
```

Instead of storing a column name like `"GDP"`, RDF triples can point to an exact definition of GDP from a recognised vocabulary, ensuring consistent meaning across datasets.

::: small
```{r}
cat(one_triple)
```
:::

```{r readrdf}
# We write to a temporary file our N-triples created earlier
# Initialise a connection, this time in tempfile().
temp_file <- tempfile(fileext = ".nt")

# Write the text into the connection:
writeLines(ntriples, con = temp_file)

# Initialise an RDF graph in memory:
rdf_graph <- rdf()
```

Read the contents of the temporary text file into the graph:

::: small
```{r showgraph}
rdf_parse(rdf_graph, doc = temp_file, format = "ntriples")
```
:::

## Clean up

When working with RDF output in R, it is good practice to close any file connections and remove large in-memory objects once they are no longer needed.  
This helps free memory and avoids leaving temporary files behind.

```{r clenup}
# Clean up: delete file and clear RDF graph
unlink(temp_file)
rm(rdf_graph)
gc()
```

## Scale up

The same approach used for the small example can be applied to a complete `dataset_df`. In this example, we add multiple variables, each defined with labels, units, concepts, and (where appropriate) namespaces, along with a dataset-level bibliographic record.

```{r scaleup}
small_country_dataset <- dataset_df(
  geo = defined(
    gdp$geo,
    label = "Country name",
    concept = "http://dd.eionet.europa.eu/vocabulary/eurostat/geo/",
    namespace = "https://www.geonames.org/countries/$1/"
  ),
  year = defined(
    gdp$year,
    label = "Reference Period (Year)",
    concept = "http://purl.org/linked-data/sdmx/2009/dimension#refPeriod"
  ),
  gdp = defined(
    gdp$gdp,
    label = "Gross Domestic Product",
    unit = "CP_MEUR",
    concept = "http://data.europa.eu/83i/aa/GDP"
  ),
  unit = gdp$unit,
  freq = defined(
    gdp$freq,
    label = "Frequency",
    concept = "http://purl.org/linked-data/sdmx/2009/code",
    namespace = "http://purl.org/linked-data/sdmx/2009/code#freq-"
  ),
  dataset_bibentry = dublincore(
    title = "Small Country Dataset",
    creator = person("Jane", "Doe"),
    publisher = "Example Inc.",
    datasource = "https://doi.org/10.2908/NAIDA_10_GDP",
    rights = "CC-BY",
    coverage = "Andorra, Lichtenstein and San Marino"
  )
)
```

Once the dataset is fully defined, it can be converted to RDF triples in N-Triples format:

```{r smallcountrydfnt}
small_country_df_nt <- dataset_to_triples(small_country_dataset,
  format = "nt"
)
```

The following statements illustrate the output:

-   [1] `Observation #1` is a geopolitical entity, `Andorra`.
-   [11] `Observation #1` has a reference time period of `2020`.
-   [21] `Observation #1` has a decimal GDP value of `2354.8`
-   [31] `Observation #1` has a unit of `million euros, current prices`.
-   [41] `Observation #1` has a measurement frequency that is `annual`.

```{r smallcountrydfntsample}
## See rows 1,11,21
small_country_df_nt[c(1, 11, 21, 31, 41)]
```

RDF triples are not guaranteed to be serialised in the same order as the dataset’s rows and columns.  
This is not a limitation — each triple explicitly encodes the observation (subject) and the variable (predicate), making it possible to reconstruct the original dataset from the triples alone.

The statements about `Observation #1` (Andorra’s national economy in 2020) are not consecutive in the text file.  
This is fine because the mapping to both the *row* and *column* is embedded in the triple structure, allowing the RDF to be imported directly into a database without ambiguity.


```{r readrdf2}
# We write to a temporary file our Ntriples created earlier
temp_file <- tempfile(fileext = ".nt")
writeLines(small_country_df_nt,
  con = temp_file
)

rdf_graph <- rdf()
rdf_parse(rdf_graph, doc = temp_file, format = "ntriples")
rdf_graph
```

At this point, your dataset is ready for export in a FAIR-compliant format:

- **Self-descriptive** — variables carry labels, units, and precise definitions  
- **Machine-readable** — linked to standard vocabularies and identifiers  
- **Ready to publish and share** — includes metadata for variables, observation units, and the dataset itself via standards like Dublin Core and DataCite


```{r readjsonld}
# Create temporary JSON-LD output file
jsonld_file <- tempfile(fileext = ".jsonld")

# Serialize (export) the entire graph to JSON-LD format
rdf_serialize(rdf_graph, doc = jsonld_file, format = "jsonld")
```

To verify the output, you can read the JSON-LD back into R (first 30 lines shown):


:::: small
```{r readjsonldprint}
cat(readLines(jsonld_file)[1:30], sep = "\n")
```
::::

Finally, remove temporary files and clear objects from memory to free resources.


```{r clenup2, message=FALSE}
unlink(temp_file)
rm(rdf_graph)
gc()
```


